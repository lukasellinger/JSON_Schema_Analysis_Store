{
  "$id": "settings-2-1.schema.json",
  "$ref": "#/definitions/ServerConfigSchema",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "ServerConfigSchema": {
      "additionalProperties": false,
      "properties": {
        "$schema": {
          "description": "The JSON schema location for this document. This schema is generated \ndirectly from the TypeScript interfaces\nused in TiddlyServer. A text-editor with autocomplete, such as VS code, \nwill make editing this file much simpler. \nMost fields include a description like this one. \n\nAll relative paths in this file are resolved relative to this file, so \n`./settings-tree.xml` refers to an XML file in the same folder as this file. \nAll relative paths in included files (such as the XML file) are resolved \nrelative to the included file.",
          "type": "string"
        },
        "_datafoldertarget": {
          "description": "The tiddlywiki folder to use for data folder instances. Defaults to the \ntiddlywiki folder in the TiddlyServer installation regardless of the \nsettings.json location.",
          "type": "string"
        },
        "_devmode": {
          "description": "enables certain expensive per-request checks",
          "type": "boolean"
        },
        "authAccounts": {
          "additionalProperties": {
            "$ref": "#/definitions/ServerConfig_AuthAccountsValue"
          },
          "description": "The Hashmap of accounts which may authenticate on this server.\nTakes either an object or a string to a `require`-able file (such as .js or .json) \nwhich exports the object",
          "type": "object"
        },
        "authCookieAge": {
          "description": "Age to set for the auth cookie (default is 30 days)\n- 24 hours: `86400`\n- 7 days: `604800`\n- 30 days: `2592000`\n- 60 days: `5184000`\n- 90 days: `7776000`\n- 120 days: `10368000`\n- 150 days: `12950000`\n- 180 days: `15552000`",
          "type": "number"
        },
        "bindInfo": {
          "additionalProperties": false,
          "description": "bind address and port info",
          "properties": {
            "_bindLocalhost": {
              "description": "always bind a separate server instance to 127.0.0.1 regardless of any other settings",
              "type": "boolean"
            },
            "bindAddress": {
              "description": "An array of IP addresses to accept requests on. Can be any IP address\nassigned to the machine. Default is \"127.0.0.1\".\n\nIf `bindWildcard` is true, each connection is checked individually. Otherwise, the server listens\non the specified IP addresses and accepts all connections from the operating system. If an IP address\ncannot be bound, the server skips it unless `--bindAddressRequired` is specified\n\nIf `filterBindAddress` is true, IPv4 addresses may include a subnet mask,\n(e.g. `/24`) which matches any interface IP address in that range. Prefix with a minus sign (-) \nto block requests incoming to that IP address or range.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "bindWildcard": {
              "description": "Bind to the wildcard addresses `0.0.0.0` and `::` (if enabled) in that order.\nThe default is `true`. In many cases this is preferred, however \nAndroid does not support this for some reason. On Android, set this to\n`false` and set host to `[\"0.0.0.0/0\"]` to bind to all IPv4 addresses.",
              "enum": [
                true,
                false
              ],
              "type": "boolean"
            },
            "enableIPv6": {
              "description": "Bind to the IPv6 wildcard as well if `bindWilcard` is true and allow requests\nincoming to IPv6 addresses if not explicitly denied.",
              "type": "boolean"
            },
            "filterBindAddress": {
              "description": "IPv4 addresses may include a subnet mask,\n(e.g. `/24`) which matches any IP address in that range. Prefix with a minus sign (-) \nto block requests incoming to that IP address or range.",
              "type": "boolean"
            },
            "https": {
              "description": "https-only options: a string to a JavaScript file which exports a function of type\n`(iface:string) \u003d\u003e https.ServerOptions`. Note that the initServer function will \nchange this to a boolean value indicating whether https is in use once inside TiddlyServer.",
              "type": "string"
            },
            "localAddressPermissions": {
              "additionalProperties": {
                "$ref": "#/definitions/ServerConfig_AccessOptions"
              },
              "default": {
                "localhost": {
                  "mkdir": true,
                  "putsaver": true,
                  "registerNotice": true,
                  "upload": true,
                  "websockets": true,
                  "writeErrors": true
                }
              },
              "description": "Permissions based on local address: \"localhost\", \"*\" (all others), \"192.168.0.0/16\", etc. \nThis checks the IP address each client connects to (socket.localAddress), \nnot the bind address of the server instance that accepted the request.",
              "type": "object"
            },
            "port": {
              "description": "port to listen on, default is 8080 for http and 8443 for https",
              "type": "number"
            }
          },
          "type": "object"
        },
        "datafolder": {
          "description": "Options object whose properties will be passed to the tiddlywiki server instance using the spread operator.\nIf a property specifies an object instead of a string, the object will be shared between all instances.",
          "type": "object"
        },
        "directoryIndex": {
          "additionalProperties": false,
          "description": "directory index options",
          "properties": {
            "defaultType": {
              "description": "default format for the directory index",
              "enum": [
                "html",
                "json"
              ],
              "type": "string"
            },
            "icons": {
              "additionalProperties": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "description": "Hashmap of type { \"icon_name\": [\".ext\", \"mime/type\"]} where ext represents the extensions to use this icon for. \nIcons are in the TiddlyServer/assets/icons folder.",
              "type": "object"
            },
            "mimetypes": {
              "additionalProperties": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "description": "additional extensions to apply to mime types [\"mime/type\"]: [\"htm\", \"html\"]",
              "type": "object"
            },
            "mixFolders": {
              "description": "sort folder and files together rather than separated",
              "type": "boolean"
            },
            "types": {
              "not": {}
            }
          },
          "type": "object"
        },
        "logging": {
          "additionalProperties": false,
          "description": "logging",
          "properties": {
            "debugLevel": {
              "description": "4 - Errors that require the process to exit for restart\n3 - Major errors that are handled and do not require a server restart\n2 - Warnings or errors that do not alter the program flow but need to be marked (minimum for status 500)\n1 - Info - Most startup messages\n0 - Normal debug messages and all software and request-side error messages\n-1 - Detailed debug messages from high level apis\n-2 - Response status messages and error response data\n-3 - Request and response data for all messages (verbose)\n-4 - Protocol details and full data dump (such as encryption steps and keys)",
              "type": "number"
            },
            "logAccess": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "enum": [
                    false
                  ],
                  "type": "boolean"
                }
              ],
              "description": "access log file"
            },
            "logColorsToFile": {
              "description": "write the console color markers to file, useful if you read the logs by printing them to a terminal",
              "type": "boolean"
            },
            "logError": {
              "description": "error log file",
              "type": "string"
            },
            "logToConsoleAlso": {
              "description": "print access and error events to the console regardless of whether they are logged to a file",
              "type": "boolean"
            }
          },
          "type": "object"
        },
        "maxTransferRequests": {
          "description": "Max concurrent transfer requests",
          "type": "number"
        },
        "putsaver": {
          "additionalProperties": false,
          "description": "tiddlyserver specific options",
          "properties": {
            "backupFolder": {
              "description": "Backup folder to store backups in. Multiple folder paths can backup to the same folder if desired.",
              "type": "string"
            },
            "enabled": {
              "description": "If false, disables the put saver globally",
              "type": "boolean"
            },
            "etag": {
              "description": "Whether to use the etag field -- if not specified then it will check it if presented.\nThis does not affect the backup etagAge option, as the saving mechanism will still \nsend etags back to the browser, regardless of this option.",
              "enum": [
                "required",
                "disabled",
                "optional"
              ],
              "type": "string"
            },
            "etagAge": {
              "description": "Reject an etag with a modified time that is different than the file on disk by this many seconds. \n Sometimes sync or antivirus sofware will \"touch\" a file and update the modified time without changing anything.\n Size difference will still cause the request to be rejected.",
              "type": "number"
            },
            "gzipBackups": {
              "description": "GZip backup file to save disk space. Good for larger wikis. Turn this off for experimental wikis that you often need to restore from a backup because of a bad line of code (I speak from experience).",
              "type": "boolean"
            }
          },
          "type": "object"
        },
        "tree": {
          "$ref": "#/definitions/settings-2-1-tree.schema.json"
        }
      },
      "required": [
        "tree",
        "$schema"
      ],
      "type": "object"
    },
    "ServerConfig_AccessOptions": {
      "additionalProperties": false,
      "default": {
        "mkdir": true,
        "putsaver": true,
        "registerNotice": true,
        "upload": true,
        "websockets": true,
        "writeErrors": true
      },
      "properties": {
        "loginlink": {
          "description": "link to the login page when returning auth errors",
          "type": "boolean"
        },
        "mkdir": {
          "description": "allow create directory on directory index page",
          "type": "boolean"
        },
        "putsaver": {
          "description": "allow the putsaver to be used",
          "type": "boolean"
        },
        "registerNotice": {
          "description": "login attempts for a public/private key pair which has not been \nregistered will be logged at debug level 2 with the full public key\nwhich can be copied into an authAccounts entry.",
          "type": "boolean"
        },
        "transfer": {
          "description": "Allows two clients to communicate through the server",
          "type": "boolean"
        },
        "upload": {
          "description": "allow uploads on the directory index page",
          "type": "boolean"
        },
        "websockets": {
          "description": "allow websocket connections (default true)",
          "type": "boolean"
        },
        "writeErrors": {
          "description": "write error messages to the browser",
          "type": "boolean"
        }
      },
      "required": [
        "putsaver",
        "writeErrors",
        "upload",
        "mkdir",
        "websockets",
        "registerNotice",
        "loginlink",
        "transfer"
      ],
      "type": "object"
    },
    "ServerConfig_AuthAccountsValue": {
      "additionalProperties": false,
      "properties": {
        "clientKeys": {
          "additionalProperties": {
            "additionalProperties": false,
            "description": "Changing the public key or cookie suffix will require the user to log in again.",
            "properties": {
              "cookieSalt": {
                "description": "String which will be added to the cookie by the server.\nChanging it will invalidate all current cookies for this user,\nwhich requires them to login again on each device. \n`node -e \"console.log(Date.now())\"` will print the current timestamp,\nwhich you can use to make sure you get one that you\u0027ve never used it before.",
                "type": "string"
              },
              "publicKey": {
                "description": "public key",
                "type": "string"
              }
            },
            "required": [
              "publicKey",
              "cookieSalt"
            ],
            "type": "object"
          },
          "default": {
            "username": {
              "cookieSalt": "",
              "publicKey": ""
            }
          },
          "type": "object"
        },
        "permissions": {
          "$ref": "#/definitions/ServerConfig_AccessOptions",
          "default": {
            "loginlink": true,
            "mkdir": true,
            "putsaver": true,
            "registerNotice": true,
            "upload": true,
            "websockets": true,
            "writeErrors": true
          },
          "description": "override hostLevelPermissions for users with this account"
        }
      },
      "required": [
        "clientKeys",
        "permissions"
      ],
      "type": "object"
    },
    "settings-2-1-tree.schema.json": {
      "$schema": "http://json-schema.org/draft-06/schema#",
      "definitions": {
        "GroupChildrenHashmap": {
          "type": "object",
          "description": "An object with any type of mount item, using the key as the mount point. The key property of an item will be ignored.",
          "patternProperties": {
            "^[^$]+$": {
              "anyOf": [
                {
                  "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupRecordItem"
                },
                {
                  "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderRecordItem"
                },
                {
                  "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderPathShorthand"
                },
                {
                  "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupChildrenHashmap"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "GroupChildrenArray": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupArrayItem"
              },
              {
                "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderArrayItem"
              },
              {
                "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderPathShorthand"
              }
            ]
          },
          "description": "An array of children, which must specify the key property. If folder is specified as a string, the key will be the folder name"
        },
        "GroupRecordItem": {
          "type": "object",
          "additionalProperties": false,
          "patternProperties": {
            "^key$": {
              "type": "string"
            }
          },
          "properties": {
            "$element": {
              "description": "This is a group",
              "enum": [
                "group"
              ]
            },
            "indexPath": {
              "type": "string"
            },
            "$children": {
              "oneOf": [
                {
                  "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupChildrenArray"
                },
                {
                  "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupChildrenHashmap"
                }
              ]
            },
            "$options": {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_OptionsArray"
            }
          },
          "required": [
            "$children",
            "$element"
          ],
          "description": "A group creates a virtual mount folder to group folders together. The $children property may be an array or object."
        },
        "FolderRecordItem": {
          "type": "object",
          "additionalProperties": false,
          "patternProperties": {
            "^key$": {
              "type": "string"
            }
          },
          "properties": {
            "$element": {
              "description": "This is a folder",
              "enum": [
                "folder"
              ]
            },
            "path": {
              "type": "string",
              "description": "The folder path to mount"
            },
            "$options": {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_OptionsArray"
            }
          },
          "required": [
            "$element",
            "path"
          ],
          "description": "The folder element mounts a folder"
        },
        "GroupArrayItem": {
          "allOf": [
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GenericArrayItem"
            },
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupRecordItem"
            }
          ]
        },
        "FolderArrayItem": {
          "allOf": [
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GenericArrayItem"
            },
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderRecordItem"
            }
          ]
        },
        "GenericArrayItem": {
          "properties": {
            "key": {
              "type": "string",
              "description": "The mount name that will show in the URL"
            }
          },
          "required": [
            "key"
          ]
        },
        "FolderPathShorthand": {
          "type": "string",
          "description": "The path of a folder to mount without any extra options. The folder name will be used for the url name."
        },
        "OptionsArray": {
          "$ref": "#/definitions/settings-2-1-tree-options.schema.json"
        }
      },
      "allOf": [
        {
          "description": "The tree property accepts one of 3 formats. \n\n- A string ending in `.xml`, `.js`, or `.json`. The tree will be loaded from the specified path. JS and JSON files must export a `tree` property and XML files must specify a `tree` element as root.\n- A path element (or a string specifying the path) to mount a path as root (a single file is possible but pointless)\n- A group element or the children of a group element (which is either an array, or an object with no $element property)"
        },
        {
          "oneOf": [
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupChildrenHashmap"
            },
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupChildrenArray"
            },
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupRecordItem"
            },
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderRecordItem"
            },
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderPathShorthand"
            }
          ]
        }
      ]
    },
    "settings-2-1-tree.schema.json_definitions_GroupRecordItem": {
      "type": "object",
      "additionalProperties": false,
      "patternProperties": {
        "^key$": {
          "type": "string"
        }
      },
      "properties": {
        "$element": {
          "description": "This is a group",
          "enum": [
            "group"
          ]
        },
        "indexPath": {
          "type": "string"
        },
        "$children": {
          "oneOf": [
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupChildrenArray"
            },
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupChildrenHashmap"
            }
          ]
        },
        "$options": {
          "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_OptionsArray"
        }
      },
      "required": [
        "$children",
        "$element"
      ],
      "description": "A group creates a virtual mount folder to group folders together. The $children property may be an array or object."
    },
    "settings-2-1-tree.schema.json_definitions_GroupChildrenArray": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupArrayItem"
          },
          {
            "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderArrayItem"
          },
          {
            "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderPathShorthand"
          }
        ]
      },
      "description": "An array of children, which must specify the key property. If folder is specified as a string, the key will be the folder name"
    },
    "settings-2-1-tree.schema.json_definitions_GroupArrayItem": {
      "allOf": [
        {
          "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GenericArrayItem"
        },
        {
          "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupRecordItem"
        }
      ]
    },
    "settings-2-1-tree.schema.json_definitions_GenericArrayItem": {
      "properties": {
        "key": {
          "type": "string",
          "description": "The mount name that will show in the URL"
        }
      },
      "required": [
        "key"
      ]
    },
    "settings-2-1-tree.schema.json_definitions_FolderArrayItem": {
      "allOf": [
        {
          "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GenericArrayItem"
        },
        {
          "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderRecordItem"
        }
      ]
    },
    "settings-2-1-tree.schema.json_definitions_FolderRecordItem": {
      "type": "object",
      "additionalProperties": false,
      "patternProperties": {
        "^key$": {
          "type": "string"
        }
      },
      "properties": {
        "$element": {
          "description": "This is a folder",
          "enum": [
            "folder"
          ]
        },
        "path": {
          "type": "string",
          "description": "The folder path to mount"
        },
        "$options": {
          "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_OptionsArray"
        }
      },
      "required": [
        "$element",
        "path"
      ],
      "description": "The folder element mounts a folder"
    },
    "settings-2-1-tree.schema.json_definitions_OptionsArray": {
      "$ref": "#/definitions/settings-2-1-tree-options.schema.json"
    },
    "settings-2-1-tree-options.schema.json": {
      "$ref": "#/definitions/settings-2-1-tree-options.schema.json_definitions_OptionsArraySchema",
      "$schema": "http://json-schema.org/draft-07/schema#",
      "definitions": {
        "Config.Options_Auth": {
          "additionalProperties": false,
          "properties": {
            "$element": {
              "description": "Only allow requests using these authAccounts. Option elements affect the group they belong to and all children under that. Each property in an auth element replaces the key from parent auth elements.\n\nAnonymous requests are ALWAYS denied if an auth list applies to the requested path. \n\nNote that this does not change server authentication procedures. Data folders are always given the authenticated username regardless of whether there are auth elements in the tree.",
              "enum": [
                "auth"
              ],
              "type": "string"
            },
            "authError": {
              "description": "Which error code to return for unauthorized (or anonymous) requests\n- 403 Access Denied: Client is not granted permission to access this resouce.\n- 404 Not Found: Client is told that the resource does not exist.",
              "enum": [
                403,
                404
              ],
              "type": "number"
            },
            "authList": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Array of keys from authAccounts object that can access this resource. Null allows all, including anonymous."
            }
          },
          "required": [
            "$element"
          ],
          "type": "object"
        },
        "Config.Options_Backups": {
          "additionalProperties": false,
          "properties": {
            "$element": {
              "description": "Options related to backups for single-file wikis. Option elements affect the group they belong to and all children under that. Each property in a backups element replaces the key from parent backups elements.",
              "enum": [
                "putsaver"
              ],
              "type": "string"
            },
            "backupFolder": {
              "description": "Backup folder to store backups in. Multiple folder paths can backup to the same folder if desired.",
              "type": "string"
            },
            "enabled": {
              "description": "If false, disables the put saver globally",
              "type": "boolean"
            },
            "etag": {
              "description": "Whether to use the etag field -- if not specified then it will check it if presented.\nThis does not affect the backup etagAge option, as the saving mechanism will still \nsend etags back to the browser, regardless of this option.",
              "enum": [
                "required",
                "disabled",
                "optional"
              ],
              "type": "string"
            },
            "etagAge": {
              "description": "Reject an etag with a modified time that is different than the file on disk by this many seconds. \n Sometimes sync or antivirus sofware will \"touch\" a file and update the modified time without changing anything.\n Size difference will still cause the request to be rejected.",
              "type": "number"
            },
            "gzipBackups": {
              "description": "GZip backup file to save disk space. Good for larger wikis. Turn this off for experimental wikis that you often need to restore from a backup because of a bad line of code (I speak from experience).",
              "type": "boolean"
            }
          },
          "required": [
            "$element",
            "backupFolder",
            "enabled",
            "etag",
            "etagAge",
            "gzipBackups"
          ],
          "type": "object"
        },
        "Config.Options_Index": {
          "additionalProperties": false,
          "properties": {
            "$element": {
              "description": "Options related to the directory index (request paths that resolve to a folder\nwhich is not a data folder). Option elements affect the group\nthey belong to and all children under that. Each property in an option element \nreplaces the key from parent option elements.",
              "enum": [
                "index"
              ],
              "type": "string"
            },
            "defaultType": {
              "description": "The format of the index generated if no index file is found, or \"403\" to \nreturn a 403 Access Denied, or 404 to return a 404 Not Found. 403 is the \nerror code used by Apache and Nginx.",
              "enum": [
                "html",
                "json",
                403,
                404
              ],
              "type": [
                "string",
                "number"
              ]
            },
            "indexExts": {
              "description": "Extensions to add when looking for an index file. A blank string will set the order \nto search for the exact indexFile name. The extensions are searched in the order specified. \n\nOnly applies to folder elements, but may be set on a group element. An empty array disables this feature.\nThe default is `[\"\"]`, which will search for an exact indexFile.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "indexFile": {
              "description": "Look for index files named exactly this or with one of the defaultExts added. \nFor example, a defaultFile of [\"index\"] and a defaultExts of [\"htm\",\"\",html\"] would \nlook for [\"index.htm\",\"index\",\"index.html\"] in that order. \n\nOnly applies to folder elements, but may be set on a group element. An empty array disables this feature.\nTo use a .hidden file, put the full filename here, and set indexExts to `[\"\"]`.",
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "required": [
            "$element"
          ],
          "type": "object"
        },
        "OptionsArraySchema": {
          "description": "The options array schema is in `settings-2-1-tree-options.schema.json`",
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/settings-2-1-tree-options.schema.json_definitions_Config.Options_Auth"
              },
              {
                "$ref": "#/definitions/settings-2-1-tree-options.schema.json_definitions_Config.Options_Backups"
              },
              {
                "$ref": "#/definitions/settings-2-1-tree-options.schema.json_definitions_Config.Options_Index"
              }
            ]
          },
          "type": "array"
        }
      }
    },
    "settings-2-1-tree-options.schema.json_definitions_OptionsArraySchema": {
      "description": "The options array schema is in `settings-2-1-tree-options.schema.json`",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/settings-2-1-tree-options.schema.json_definitions_Config.Options_Auth"
          },
          {
            "$ref": "#/definitions/settings-2-1-tree-options.schema.json_definitions_Config.Options_Backups"
          },
          {
            "$ref": "#/definitions/settings-2-1-tree-options.schema.json_definitions_Config.Options_Index"
          }
        ]
      },
      "type": "array"
    },
    "settings-2-1-tree-options.schema.json_definitions_Config.Options_Auth": {
      "additionalProperties": false,
      "properties": {
        "$element": {
          "description": "Only allow requests using these authAccounts. Option elements affect the group they belong to and all children under that. Each property in an auth element replaces the key from parent auth elements.\n\nAnonymous requests are ALWAYS denied if an auth list applies to the requested path. \n\nNote that this does not change server authentication procedures. Data folders are always given the authenticated username regardless of whether there are auth elements in the tree.",
          "enum": [
            "auth"
          ],
          "type": "string"
        },
        "authError": {
          "description": "Which error code to return for unauthorized (or anonymous) requests\n- 403 Access Denied: Client is not granted permission to access this resouce.\n- 404 Not Found: Client is told that the resource does not exist.",
          "enum": [
            403,
            404
          ],
          "type": "number"
        },
        "authList": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "description": "Array of keys from authAccounts object that can access this resource. Null allows all, including anonymous."
        }
      },
      "required": [
        "$element"
      ],
      "type": "object"
    },
    "settings-2-1-tree-options.schema.json_definitions_Config.Options_Backups": {
      "additionalProperties": false,
      "properties": {
        "$element": {
          "description": "Options related to backups for single-file wikis. Option elements affect the group they belong to and all children under that. Each property in a backups element replaces the key from parent backups elements.",
          "enum": [
            "putsaver"
          ],
          "type": "string"
        },
        "backupFolder": {
          "description": "Backup folder to store backups in. Multiple folder paths can backup to the same folder if desired.",
          "type": "string"
        },
        "enabled": {
          "description": "If false, disables the put saver globally",
          "type": "boolean"
        },
        "etag": {
          "description": "Whether to use the etag field -- if not specified then it will check it if presented.\nThis does not affect the backup etagAge option, as the saving mechanism will still \nsend etags back to the browser, regardless of this option.",
          "enum": [
            "required",
            "disabled",
            "optional"
          ],
          "type": "string"
        },
        "etagAge": {
          "description": "Reject an etag with a modified time that is different than the file on disk by this many seconds. \n Sometimes sync or antivirus sofware will \"touch\" a file and update the modified time without changing anything.\n Size difference will still cause the request to be rejected.",
          "type": "number"
        },
        "gzipBackups": {
          "description": "GZip backup file to save disk space. Good for larger wikis. Turn this off for experimental wikis that you often need to restore from a backup because of a bad line of code (I speak from experience).",
          "type": "boolean"
        }
      },
      "required": [
        "$element",
        "backupFolder",
        "enabled",
        "etag",
        "etagAge",
        "gzipBackups"
      ],
      "type": "object"
    },
    "settings-2-1-tree-options.schema.json_definitions_Config.Options_Index": {
      "additionalProperties": false,
      "properties": {
        "$element": {
          "description": "Options related to the directory index (request paths that resolve to a folder\nwhich is not a data folder). Option elements affect the group\nthey belong to and all children under that. Each property in an option element \nreplaces the key from parent option elements.",
          "enum": [
            "index"
          ],
          "type": "string"
        },
        "defaultType": {
          "description": "The format of the index generated if no index file is found, or \"403\" to \nreturn a 403 Access Denied, or 404 to return a 404 Not Found. 403 is the \nerror code used by Apache and Nginx.",
          "enum": [
            "html",
            "json",
            403,
            404
          ],
          "type": [
            "string",
            "number"
          ]
        },
        "indexExts": {
          "description": "Extensions to add when looking for an index file. A blank string will set the order \nto search for the exact indexFile name. The extensions are searched in the order specified. \n\nOnly applies to folder elements, but may be set on a group element. An empty array disables this feature.\nThe default is `[\"\"]`, which will search for an exact indexFile.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "indexFile": {
          "description": "Look for index files named exactly this or with one of the defaultExts added. \nFor example, a defaultFile of [\"index\"] and a defaultExts of [\"htm\",\"\",html\"] would \nlook for [\"index.htm\",\"index\",\"index.html\"] in that order. \n\nOnly applies to folder elements, but may be set on a group element. An empty array disables this feature.\nTo use a .hidden file, put the full filename here, and set indexExts to `[\"\"]`.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "$element"
      ],
      "type": "object"
    },
    "settings-2-1-tree.schema.json_definitions_FolderPathShorthand": {
      "type": "string",
      "description": "The path of a folder to mount without any extra options. The folder name will be used for the url name."
    },
    "settings-2-1-tree.schema.json_definitions_GroupChildrenHashmap": {
      "type": "object",
      "description": "An object with any type of mount item, using the key as the mount point. The key property of an item will be ignored.",
      "patternProperties": {
        "^[^$]+$": {
          "anyOf": [
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupRecordItem"
            },
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderRecordItem"
            },
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_FolderPathShorthand"
            },
            {
              "$ref": "#/definitions/settings-2-1-tree.schema.json_definitions_GroupChildrenHashmap"
            }
          ]
        }
      },
      "additionalProperties": false
    }
  }
}